<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet"/><script src="http://code.jquery.com/jquery-1.9.1.min.js"></script><script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script><link href="../../styles.css" rel="stylesheet"/><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["flixel"]};</script><script type="text/javascript" src="../../nav.js"></script><script type="text/javascript" src="../../index.js"></script><link rel="icon" href="../../favicon.ico" type="image/x-icon"></link><title>package geom</title></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><form class="navbar-search pull-left" id="searchForm"><input id="search" type="text" class="search-query" placeholder="Filter" autocomplete="off"/></form><ul class="nav"><li id="select-platform" class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Platform<b class="caret"></b></a><ul class="dropdown-menu"><li data="all"><a href="#">All Platforms</a></li><li data="flixel"><a href="#">flixel</a></li></ul></li></ul></div></div><div id="container"><div id="nav"></div><div id="content"><h1><span class="directive">package</span> nape.geom</h1><table class="table table-condensed"><tbody><tr><td width="200"><a href="../../nape/geom/AABB.html">AABB</a></td><td><p>Axis Aligned Bounding Box (AABB)
<br/><br/>
Note that in many cases of an AABB object being returned by a Nape function
the AABB object will be marked internally as an 'immutable' AABB. This will
always be documented and trying to mutate such an AABB will result in an
error being thrown.</p></td></tr><tr><td width="200"><a href="../../nape/geom/ConvexResult.html">ConvexResult</a></td><td><p>Class representing the results of a convex cast operation.
<br/><br/>
These objects are allocated from an object pool and can
be released back to that pool by calling its dispose method.</p></td></tr><tr><td width="200"><a href="../../nape/geom/ConvexResultIterator.html">ConvexResultIterator</a></td><td><p>Haxe Iterator<T> compatible iterator over Nape list.</p></td></tr><tr><td width="200"><a href="../../nape/geom/ConvexResultList.html">ConvexResultList</a></td><td><p>Nape list of ConvexResult type objects
<br/><br/>
Internally this list is at present implemented as a linked list with
object pooled nodes and iterators with various fast paths made for
standard access patterns (For instance accessing successive elements
runs in constant time when using random access functions)
<br/><br/>
Iteration of this list can be done in various ways, but the preferred
way on all targets, is through use of the foreach function:
<pre>
list.foreach(function (obj) {
});
</pre>
This method is inlined so that in haxe no closure will need to be created.
<br/><br/>
In AS3, a closure would need to be created in general, so for performance
reasons you 'may' choose to use iteration as follows:
<pre>
for (var i:int = 0; i &lt; list.length; i++) {
    var obj:ConvexResult = list.at(i);
}
</pre>
<br/>
NOTE: It is 'not' safe to modify a list whilst iterating over it.
If you wish to remove elements during an iteration you should use the
filter method, for example:
<pre>
list.filter(function (obj) {
    // operate on object.
    // ...
    return (false if you want object to be removed);
});
</pre>
<br/><br/>
In AS3, if you wish to avoid a closure generation, you can perform such
an iteration in a safe manner as follows:
<pre>
var i:int = 0;
while (i &lt; list.length) {
    var obj:ConvexResult = list.at(i);
    // operate on object.
    // ...
    if (should remove obj) {
        list.remove(obj);
        continue;
    }
    else i++;
}
</pre>
Or if you are always clearing the list entirely you could write:
<pre>
while (!list.empty()) {
    var obj:ConvexResult = list.pop();
    // operate on object.
    // ...
}
</pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/Geom.html">Geom</a></td><td><p>Geom class provides interface to collision detection routines in nape.</p></td></tr><tr><td width="200"><a href="../../nape/geom/GeomPoly.html">GeomPoly</a></td><td><p>Polygon class with various geometric methods
<br/><br/>
This class represents a general Polygon, rather than the Polygon class
which is physics shape.
<br/><br/>
Internally this polygon is stored as a circularly linked list of special
vertex types that are exposed via a Vec2 that is lazily constructed whenever
necessary to the API.</p></td></tr><tr><td width="200"><a href="../../nape/geom/GeomPolyIterator.html">GeomPolyIterator</a></td><td><p>Haxe Iterator<T> compatible iterator over Nape list.</p></td></tr><tr><td width="200"><a href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></td><td><p>Nape list of GeomPoly type objects
<br/><br/>
Internally this list is at present implemented as a linked list with
object pooled nodes and iterators with various fast paths made for
standard access patterns (For instance accessing successive elements
runs in constant time when using random access functions)
<br/><br/>
Iteration of this list can be done in various ways, but the preferred
way on all targets, is through use of the foreach function:
<pre>
list.foreach(function (obj) {
});
</pre>
This method is inlined so that in haxe no closure will need to be created.
<br/><br/>
In AS3, a closure would need to be created in general, so for performance
reasons you 'may' choose to use iteration as follows:
<pre>
for (var i:int = 0; i &lt; list.length; i++) {
    var obj:GeomPoly = list.at(i);
}
</pre>
<br/>
NOTE: It is 'not' safe to modify a list whilst iterating over it.
If you wish to remove elements during an iteration you should use the
filter method, for example:
<pre>
list.filter(function (obj) {
    // operate on object.
    // ...
    return (false if you want object to be removed);
});
</pre>
<br/><br/>
In AS3, if you wish to avoid a closure generation, you can perform such
an iteration in a safe manner as follows:
<pre>
var i:int = 0;
while (i &lt; list.length) {
    var obj:GeomPoly = list.at(i);
    // operate on object.
    // ...
    if (should remove obj) {
        list.remove(obj);
        continue;
    }
    else i++;
}
</pre>
Or if you are always clearing the list entirely you could write:
<pre>
while (!list.empty()) {
    var obj:GeomPoly = list.pop();
    // operate on object.
    // ...
}
</pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/GeomVertexIterator.html">GeomVertexIterator</a></td><td><p>Haxe compatible iterator over vertices of GeomPoly.
<br/><br/>
Vec2's intrinsically tied to the vertices are exposed through
the iterator which does not modify the state of the polygon.</p></td></tr><tr><td width="200"><a href="../../nape/geom/IsoFunction.html">IsoFunction</a></td><td><p>For 'flash' targets only.
<br/><br/>
Iso-functions for MarchingSquares must be given
as an object implementing this IsoFunction interface. This is for
reasons of avoiding excessive memory allocations that occur through
automatic boxing of arguments/return values when using function values.
<br/>
Since iso-functions may be called 10,000's of times per-invocation of
marching-squares, this can quickly accumulate into a lot of GC activity.</p></td></tr><tr><td width="200"><a href="../../nape/geom/IsoFunctionDef.html">IsoFunctionDef</a></td><td><p>Typedef defining iso-function type for MarchingSquares.
<code>
typedef IsoFunctionDef = #if flash IsoFunction #else Float-&gt;Float-&gt;Float #end;
</code></p></td></tr><tr><td width="200"><a href="../../nape/geom/MarchingSquares.html">MarchingSquares</a></td><td><p>Iso-surface extraction into polygons.
<br/><br/>
This class, with only one static method provides an interface to
an algorithm which will, when given a function mapping each point
in a given AABB to a scalar value extract approximated polygons
which represent the region of the AABB where the function returns
a negative value.
<br/><br/>
This function could be a mathematical function like the equation of
a circle: <code> function (x, y) return (x<em>x + y</em>y) - r*r </code>
<br/>
Or something more practical like the biased alpha value interpolated
from a Bitmap:
<pre>
function (x, y) {
   var ix = if (x &lt; 0) 0 else if (x >= bitmap.width - 1) bitmap.width - 2 else Std.int(x);
   var iy = if (y &lt; 0) 0 else if (y >= bitmap.height - 1) bitmap.height - 2 else Std.int(y);
   var fx = x - ix;
   var fy = y - iy;
   var gx = 1 - fx;
   var gy = 1 - fy;</p></td></tr><tr><td width="200"><a href="../../nape/geom/Mat23.html">Mat23</a></td><td><p>2D Matrix class representing affine transformations:
<pre>
[ a  b  tx ]
[ c  d  ty ]
[ 0  0  1  ]
</pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/MatMN.html">MatMN</a></td><td><p>A general MxN dimensional matrix.
<br/><br/>
This object is not often used in Nape :)</p></td></tr><tr><td width="200"><a href="../../nape/geom/Ray.html">Ray</a></td><td><p>Parametrically defined ray used in ray casting functions.</p></td></tr><tr><td width="200"><a href="../../nape/geom/RayResult.html">RayResult</a></td><td><p>Class representing the results of a ray cast operation.
<br/><br/>
These objects are allocated from an object pool and can
be released back to that pool by calling its dispose method.</p></td></tr><tr><td width="200"><a href="../../nape/geom/RayResultIterator.html">RayResultIterator</a></td><td><p>Haxe Iterator<T> compatible iterator over Nape list.</p></td></tr><tr><td width="200"><a href="../../nape/geom/RayResultList.html">RayResultList</a></td><td><p>Nape list of RayResult type objects
<br/><br/>
Internally this list is at present implemented as a linked list with
object pooled nodes and iterators with various fast paths made for
standard access patterns (For instance accessing successive elements
runs in constant time when using random access functions)
<br/><br/>
Iteration of this list can be done in various ways, but the preferred
way on all targets, is through use of the foreach function:
<pre>
list.foreach(function (obj) {
});
</pre>
This method is inlined so that in haxe no closure will need to be created.
<br/><br/>
In AS3, a closure would need to be created in general, so for performance
reasons you 'may' choose to use iteration as follows:
<pre>
for (var i:int = 0; i &lt; list.length; i++) {
    var obj:RayResult = list.at(i);
}
</pre>
<br/>
NOTE: It is 'not' safe to modify a list whilst iterating over it.
If you wish to remove elements during an iteration you should use the
filter method, for example:
<pre>
list.filter(function (obj) {
    // operate on object.
    // ...
    return (false if you want object to be removed);
});
</pre>
<br/><br/>
In AS3, if you wish to avoid a closure generation, you can perform such
an iteration in a safe manner as follows:
<pre>
var i:int = 0;
while (i &lt; list.length) {
    var obj:RayResult = list.at(i);
    // operate on object.
    // ...
    if (should remove obj) {
        list.remove(obj);
        continue;
    }
    else i++;
}
</pre>
Or if you are always clearing the list entirely you could write:
<pre>
while (!list.empty()) {
    var obj:RayResult = list.pop();
    // operate on object.
    // ...
}
</pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/Vec2.html">Vec2</a></td><td><p>2 Dimensional vector.
<br/><br/>
Note that in many cases of a Vec2 object being returned by a Nape function
the Vec2 object will be marked internally as an 'immutable' Vec2. This will
always be documented and trying to mutate such a Vec2 will result in an
error being thrown.
<br/><br/>
Vec2 objects can make use of a global object pool, attempting to make use
of a disposed Vec2 will also result in an error with the object pool
working in a FILO order to increase the likelihood of such misuse being
caught.
<br/><br/>
Additionally Vec2 objects can be created as 'weak'. Passing a weak Vec2 to
any Nape function as an argument will result in the automatic disposal of
the Vec2 once the method has finished with it. There may be exceptions to
this rule which will also be documented; a notable case being the appending
of a weak Vec2 to a Nape Vec2List in which case the disposal of the weak
Vec2 is performed when that Vec2List is handed to a Nape function instead.
<br/><br/>
Example:
<pre>
var vertices = Polygon.box(20, 20, true);
var polygon = new Polygon(vertices);
</pre>
In this example, passing <code>true</code> to the Polygon.box method means
that we will be returned a Vec2List containing only 'weak' Vec2s. Upon
passing this Vec2List to the Polygon constructor, all of the Vec2s from
that list will be automatically disposed.</p></td></tr><tr><td width="200"><a href="../../nape/geom/Vec2Iterator.html">Vec2Iterator</a></td><td><p>Haxe Iterator<T> compatible iterator over Nape list.</p></td></tr><tr><td width="200"><a href="../../nape/geom/Vec2List.html">Vec2List</a></td><td><p>Nape list of Vec2 type objects
<br/><br/>
Internally this list is at present implemented as a linked list with
object pooled nodes and iterators with various fast paths made for
standard access patterns (For instance accessing successive elements
runs in constant time when using random access functions)
<br/><br/>
Iteration of this list can be done in various ways, but the preferred
way on all targets, is through use of the foreach function:
<pre>
list.foreach(function (obj) {
});
</pre>
This method is inlined so that in haxe no closure will need to be created.
<br/><br/>
In AS3, a closure would need to be created in general, so for performance
reasons you 'may' choose to use iteration as follows:
<pre>
for (var i:int = 0; i &lt; list.length; i++) {
    var obj:Vec2 = list.at(i);
}
</pre>
<br/>
NOTE: It is 'not' safe to modify a list whilst iterating over it.
If you wish to remove elements during an iteration you should use the
filter method, for example:
<pre>
list.filter(function (obj) {
    // operate on object.
    // ...
    return (false if you want object to be removed);
});
</pre>
<br/><br/>
In AS3, if you wish to avoid a closure generation, you can perform such
an iteration in a safe manner as follows:
<pre>
var i:int = 0;
while (i &lt; list.length) {
    var obj:Vec2 = list.at(i);
    // operate on object.
    // ...
    if (should remove obj) {
        list.remove(obj);
        continue;
    }
    else i++;
}
</pre>
Or if you are always clearing the list entirely you could write:
<pre>
while (!list.empty()) {
    var obj:Vec2 = list.pop();
    // operate on object.
    // ...
}
</pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/Vec3.html">Vec3</a></td><td><p>A 3 dimensional vector object.
<br/><br/>
In many instances a Vec3 will be accessible from Nape which is marked
as immutable, these cases will be documented and modifying such a Vec3
will result in an error.</p></td></tr><tr><td width="200"><a href="../../nape/geom/Winding.html">Winding</a></td><td><p>Enumeration represents the winding of a Polygon.
<br/><br/>
To appreciate what the winding of a polygon means, think of a polygon who's
vertices are the numbers on a clock face.</p></td></tr></tbody></table></div></div></body></html>