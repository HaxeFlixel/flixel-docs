<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap-combined.min.css" rel="stylesheet" /><script type="text/javascript" src="../../jquery-1.9.1.min.js"></script><script type="text/javascript" src="../../bootstrap.min.js"></script><link href="../../styles.css" rel="stylesheet" /><link rel="icon" href="../../favicon.ico" type="image/x-icon"></link><script type="text/javascript" src="../../nav.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["flash"],showInheritedFields: false};</script><title>nape.geom.Geom - HaxeFlixel API docs</title></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><form class="navbar-search pull-left" id="searchForm"><input id="search" type="text" class="search-query" placeholder="Filter" autocomplete="off"/></form><ul class="nav"><li id="select-platform" class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Platform<b class="caret"></b></a><ul class="dropdown-menu"><li data="all"><a href="#">All Platforms</a></li><li data="flash"><a href="#">flash</a></li></ul></li></ul></div></div><div id="container"><div id="nav"></div><div id="content"><div class="header"><span class="viewsource"><a href="https://github.com/HaxeFlixel/flixel/tree/master/nape/geom/Geom.hx">View source</a></span><h1><code><span class="directive">class </span><span class="type">nape.geom.Geom</span></code></h1></div><div class="body"><p class="availability">Available on all platforms</p><div class="doc"><p>Geom class provides interface to collision detection routines in nape.</p></div><h2>Class Fields</h2><div class="not-inherited"><div class="platform platform-flash"><a name="contains"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#contains"><span class="identifier">contains</span></a>(shape1:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, shape2:<a class="type" href="../../nape/shape/Shape.html">Shape</a>):<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if one Shape is entirely contained within another.
<br/><br/>
The input Shapes must belong to a Body so that their world positions
and orientations are defined; these Bodies need not be different nor
part of any Space.</p><table class="table table-condensed"><tbody><col width="10%"/>  <col width="100%"/><tr><th colspan="2">Parameters:</th></tr><tr><td>shape1</td><td><p>this shape must belong to a Body.</p></td></tr><tr><td>shape2</td><td><p>this shape must belong to a Body.</p></td></tr><tr><th>Returns:</th><td><p>True if shape2 is completely contained within shape1.</p></td></tr><tr><th colspan="2">Throws:</th></tr><tr><td>#</td><td><p>If shape1.body or shape2.body is null.</p></td></tr></tbody></table></div></div></div><div class="not-inherited"><div class="platform platform-flash"><a name="distance"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#distance"><span class="identifier">distance</span></a>(shape1:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, shape2:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, out1:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, out2:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>):<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Determine distance and closest points between two Shapes.
<br/><br/>
The input Shapes must belong to a Body so that their world positions
and orientations are defined; these Bodies need not be different nor
part of any Space.
<br/><br/>
If the shapes are intersecting, then a negative value is returned
equal to the penetration of the shapes, and the out1/out2 vectors
will still be meaningful with their difference being the minimum
translational vector to seperate the Shapes.
<br/><br/>
As the out1/out2 vectors are used to return values from the function,
this is one of the rare cases where should out1/out2 be weak Vec2's
they will 'not' be sent to the global object pool on being passed to
this function.
<pre>
var closest1 = Vec2.get();
var closest2 = Vec2.get();
var distance = Geom.distance(shape1, shape2, out1, out2);
if (distance &lt; 0) {</p>
<pre><code>trace("Shapes intersect and penetration distance is " +
      (-distance) + " with witness points " + closest1.toString() +
      " &lt;-&gt; " + closest2.toString());
</code></pre>
<p>}else {</p>
<pre><code>trace("Shapes do not intersect and distance betweem them is " +
      distance + " with closest points " + closest1.toString() +
      " &lt;-&gt; " + closest2.toString());
</code></pre>
<p>}
</pre></p><table class="table table-condensed"><tbody><col width="10%"/>  <col width="100%"/><tr><th colspan="2">Parameters:</th></tr><tr><td>shape1</td><td><p>this shape must belong to a Body.</p></td></tr><tr><td>shape2</td><td><p>this shape must belong to a Body.</p></td></tr><tr><td>out1</td><td><p>This Vec2 object will be populated with coordinates of
closest point on shape1.</p></td></tr><tr><td>out2</td><td><p>This Vec2 object will be populated with coordinates of
closest point on shape2.</p></td></tr><tr><th>Returns:</th><td><p>The distance between the two shapes if seperated, or the
penetration distance (negative) if intersecting.</p></td></tr><tr><th colspan="2">Throws:</th></tr><tr><td>#</td><td><p>If shape1.body is null or shape2.body is null.</p></td></tr><tr><td>#</td><td><p>If out1 or out2 has been disposed.</p></td></tr><tr><td>#</td><td><p>If out1 or out2 is immutable.</p></td></tr></tbody></table></div></div></div><div class="not-inherited"><div class="platform platform-flash"><a name="distanceBody"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#distanceBody"><span class="identifier">distanceBody</span></a>(body1:<a class="type" href="../../nape/phys/Body.html">Body</a>, body2:<a class="type" href="../../nape/phys/Body.html">Body</a>, out1:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, out2:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>):<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Determine distance and closest points between two Bodies.
<br/><br/>
If the bodies are intersecting, then a negative value is returned
equal to the penetration of the bodies, and the out1/out2 vectors
will still be meaningful with their difference being the minimum
translational vector to seperate the intersecting shapes of the bodies.
(This may not be a global seperation vector as it is considering only
one pair of shapes at a time).
<br/><br/>
As the out1/out2 vectors are used to return values from the function,
this is one of the rare cases where should out1/out2 be weak Vec2's
they will 'not' be sent to the global object pool on being passed to
this function.
<pre>
var closest1 = Vec2.get();
var closest2 = Vec2.get();
var distance = Geom.distanceBody(body1, body2, out1, out2);
if (distance &lt; 0) {</p>
<pre><code>trace("Bodies intersect and penetration distance is " +
      (-distance) + " with witness points " + closest1.toString() +
      " &lt;-&gt; " + closest2.toString());
</code></pre>
<p>}else {</p>
<pre><code>trace("Bodies do not intersect and distance betweem them is " +
      distance + " with closest points " + closest1.toString() +
      " &lt;-&gt; " + closest2.toString());
</code></pre>
<p>}
</pre>
This algorithm is able to take shortcuts in culling pair tests between Shapes
based on the current state of the search, and will be more effecient than
a custom implementation that uses Geom.distance(..) method.</p><table class="table table-condensed"><tbody><col width="10%"/>  <col width="100%"/><tr><th colspan="2">Parameters:</th></tr><tr><td>body1</td><td><p>First input Body.</p></td></tr><tr><td>body2</td><td><p>Second input Body.</p></td></tr><tr><td>out1</td><td><p>This Vec2 object will be populated with coordinates of
closest point on body1.</p></td></tr><tr><td>out2</td><td><p>This Vec2 object will be populated with coordinates of
closest point on body2.</p></td></tr><tr><th>Returns:</th><td><p>The distance between the two bodies if seperated, or the
penetration distance (negative) if intersecting.</p></td></tr><tr><th colspan="2">Throws:</th></tr><tr><td>#</td><td><p>If either body has no shapes.</p></td></tr><tr><td>#</td><td><p>If out1 or out2 has been disposed.</p></td></tr><tr><td>#</td><td><p>If out1 or out2 is immutable.</p></td></tr></tbody></table></div></div></div><div class="not-inherited"><div class="platform platform-flash"><a name="intersects"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#intersects"><span class="identifier">intersects</span></a>(shape1:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, shape2:<a class="type" href="../../nape/shape/Shape.html">Shape</a>):<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if two Shapes intersect.
<br/><br/>
The input Shapes must belong to a Body so that their world positions
and orientations are defined; these Bodies need not be different nor
part of any Space.
<br/><br/>
If you do not need distance/penetration information,
then using this method will be more effecient than testing for a negative
value using the distance method.</p><table class="table table-condensed"><tbody><col width="10%"/>  <col width="100%"/><tr><th colspan="2">Parameters:</th></tr><tr><td>shape1</td><td><p>this shape must belong to a Body.</p></td></tr><tr><td>shape2</td><td><p>this shape must belong to a Body.</p></td></tr><tr><th>Returns:</th><td><p>True if the shapes are intersecting in world space.</p></td></tr><tr><th colspan="2">Throws:</th></tr><tr><td>#</td><td><p>If shape1.body or shape2.body is null.</p></td></tr></tbody></table></div></div></div><div class="not-inherited"><div class="platform platform-flash"><a name="intersectsBody"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#intersectsBody"><span class="identifier">intersectsBody</span></a>(body1:<a class="type" href="../../nape/phys/Body.html">Body</a>, body2:<a class="type" href="../../nape/phys/Body.html">Body</a>):<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if two Bodies intersect.
<br/><br/>
If you do not need distance/penetration information,
then using this method will be more effecient than testing for a negative
value using the distance method.</p><table class="table table-condensed"><tbody><col width="10%"/>  <col width="100%"/><tr><th colspan="2">Parameters:</th></tr><tr><td>body1</td><td><p>First input Body .</p></td></tr><tr><td>body2</td><td><p>Second input Body.</p></td></tr><tr><th>Returns:</th><td><p>True if the Bodies are intersecting.</p></td></tr><tr><th colspan="2">Throws:</th></tr><tr><td>#</td><td><p>If either body has no shapes.</p></td></tr></tbody></table></div></div></div><a onclick="toggleInheritedFields()">Toggle inherited fields</a></div></div></div></body></html>